/*!
 * This module implements generation of random bytes to use as passwords.
 *
 * # Password Generation
 * Before being encoded, the actual bytes for a password are generated using one
 * of couple of different methods. This page outlines the methods used, but
 * refer to the code for the exact procedure. The method used is determined by
 * the `Version` enum in a `Password` structure.
 *
 * ## Original Method
 * In my original password manager, I used a rubbish method of generating
 * passwords in which passwords were generated by interspersing dollar signs
 * among the various pieces of data, and then simply pushing it through a
 * hashing function, rehashing it if the password had been changed. For example:
 *
 *     fn original_gen(master, service, username, changes) -> Vec<char> {
 *         let mut result = sha1(format!("${}${}${}$", master, service, username));
 *
 *         for n in range(changes) {
 *             result = sha1(result);
 *         }
 *
 *         return result;
 *     }
 *
 * The resulting __hexadecimal__ characters (not the decoded bytes) were then
 * used to feed into encoding functions. This method can only produce limited
 * length passwords and due to the hexadecimal characters themselves being fed
 * to encoding functions, the resulting passwords were of poor quality and
 * lacked variety.
 *
 * ## PBKDF2 Method
 * To fix the shortcomings of the old method, the PBKDF2 method exists instead.
 * In this method, we abuse a key generation function to achieve the properties
 * that are desireable in the resulting password. First of all, PBKDF2 can
 * generate keys of any length, so the password length limit from the original
 * method is gone. Secondly, we can specify the number of rounds the key
 * function performs, we can simply use this as the number of times a password
 * has been changed. The key function also takes a salt to which we can pass the
 * master password, in fact by simply wrapping the function with a different
 * name we can repurpose it as exactly what we want:
 *
 *      fn pbkdf2_gen(master, service, username, changes) -> Vec<u8> {
 *          PBKDF2(service + username, master, changes, 20)
 *      }
 *
 *  The resulting bytes, and __not__ characters are then used for encoding,
 *  unlike the previous method the output bytes now use the full 255 value range
 *  instead of just 15 hex characters, so when fed to an encoding function the
 *  resulting password will be far more varied.
 */

use std::char;
use std::from_str::FromStr;
use store::encoding;
use serialize::{Encodable, Decodable};


/// Used to select the password generation algorithm.
#[deriving(Show, Encodable, Decodable)]
pub enum Version {
    Original,
    PBKDF2
}


/// Represents a password entry.
#[deriving(Show, Encodable, Decodable)]
pub struct Password {
    /// The service the password is for. Such as 'Google'.
    pub service:  String,
    /// The username for the service, such as an email for this Google example.
    pub username: String,
    /// The length of the resulting password (AFTER encoding).
    pub length:   u32,
    /// The number of times this password has been changed.
    pub changes:  u32,
    /// The resulting encoding that should be used, alphanumeric for example.
    pub encoding: encoding::Encoding,
    /// Which generation algorithm this password uses.
    pub version:  Version,
    /// An optional note that the password may have attached.
    pub note:     Option<String>
}


#[allow(non_snake_case)]
fn gen_Original(master: &str, password: &Password) -> Vec<u8> {
    use serialize::hex::ToHex;
    use openssl::crypto::hash::{
        hash,
        SHA512
    };

    /* First we format the data in the correct format, using the master password
     * to 'seed' the function here. */
    let hash_data = hash(SHA512, format!("${}${}${}$",
        master,
        password.service,
        password.username
    ).as_bytes());

    /* Return the data after encoding it to hex. Return bytes though as that is
     * what the encoding function will expect. */
    hash_data.as_slice().to_hex().into_bytes()
}


#[allow(non_snake_case)]
fn gen_PBKDF2(master: &str, password: &Password) -> Vec<u8> {
    ::openssl::crypto::pkcs5::pbkdf2_hmac_sha1(
        master,
        format!("{}{}", password.service, password.username).as_bytes(),
        password.changes as uint + 1,
        1024
    )
}


impl Password {
    pub fn generate(&self, master_password: &str) -> String {
        /* Select the generation algorithm, god I love Rust's expressions. */
        let bytes =
            match self.version {
                Original => gen_Original,
                PBKDF2   => gen_PBKDF2
            }(master_password, self);

        /* Encode the bytes using the encoding selected for this password. */
        let datum = self.encoding.encode_bytes(bytes.as_slice());

        /* No substr function in rust at the moment as far as I can tell, so
         * this is a little nasty, but this is how we will return a string of
         * theright length. */
        datum
            .as_slice()
            .slice(0, self.length as uint)
            .into_string()
    }

    /// Parses a password from a line formatted in the old (crap) database
    /// format. The format was in the form:
    ///
    ///     (0-9)+SERVICE:USERNAME[#LITERAL]
    pub fn from_line(line: &str) -> Option<Password> {
        /* Current state while parsing a DB line. */
        enum ParseState {
            Length,
            Detail
        }

        /* Resultant information parsed from the string. At the end of this
         * function this information is packed into a Password struct to be
         * returned. */
        let mut length: &str      = "20";
        let mut service: &str     = "";
        let mut username: &str    = "";
        let mut note: Option<String> = None;

        /* Information for parsing using a simple two state state machine and a
         * variable tracking position in the string. */
        let mut state    = Length;
        let mut position = 0;

        /* We parse the line character by character instead of just splitting
         * because the old database format SUCKED, and always started with
         * numbers. Switching from numberes to characters indicated when the
         * Service started, so there's no character to split on, we just need to
         * track state and switch when there's no numbers left. */
        for c in line.chars() {
            match state {
                /* Start by parsing the length. This continues until no numbers
                 * are left. */
                Length => {
                    if !char::is_digit(c) {
                        /* Slice out the length, and parse to a number. */
                        length = line.slice_to(position);

                        /* Move to the next state. */
                        state = Detail;
                    }
                }

                /* Then parse out the remaining Detail. */
                Detail => {
                    let parts: Vec<&str> = line
                        .slice_from(position - 1)
                        .splitn(1, ':')
                        .collect();

                    if parts.len() < 2 {
                        return None;
                    }

                    note = match line.find('#') {
                        Some(n) => Some(line.slice_from(n + 1).trim_right().to_string()),
                        _       => None
                    };

                    service  = parts[0];
                    username = parts[1].trim_right();

                    if note.is_some() {
                        username = username.slice_to(username.find('#').unwrap())
                    }

                    break;
                }
            }

            position += 1;
        }

        /* Error Handling Yo. */
        let length = FromStr::from_str(length);

        if length.is_none() {
            return None;
        }

        Some(Password {
            service:  service.to_string(),
            username: username.to_string(),
            length:   length.unwrap(),
            changes:  0,
            encoding: encoding::Ascii85,
            version:  Original,
            note:     note
        })
    }
}
